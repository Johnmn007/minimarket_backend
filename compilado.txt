================================================================================
PROYECTO: minimarket_backend
RUTA: C:\Users\Nvidia\Desktop\minimarket_backend
FECHA: Thu Jan 15 00:33:55 PET 2026
================================================================================


[FILE] pom.xml
------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.4</version> <!-- Versi√≥n m√°s reciente y estable -->
        <relativePath/>
    </parent>
    
    <groupId>com.minimarket</groupId>
    <artifactId>minimarket-backend</artifactId>
    <version>1.0.0</version>
    <name>minimarket-backend</name>
    <description>Sistema de gesti√≥n para minimarket</description>
    
    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.11.5</jjwt.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- JWT Dependencies -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Base de datos -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Lombok para reducir c√≥digo boilerplate -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Desarrollo -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

   
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>



----------

[DIR] src/

[DIR] src/main/

[DIR] src/main/java/

[DIR] src/main/java/com/

[DIR] src/main/java/com/minimarket/

[DIR] src/main/java/com/minimarket/config/

[FILE] src/main/java/com/minimarket/config/DataLoader.java
------------------------------------------------------------
package com.minimarket.config;

import com.minimarket.entity.ERole;
import com.minimarket.entity.Role;
import com.minimarket.entity.Usuario;
import com.minimarket.repository.RoleRepository;
import com.minimarket.repository.UsuarioRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Optional;

@Configuration
public class DataLoader {

    private static final Logger logger = LoggerFactory.getLogger(DataLoader.class);

    @Bean
    CommandLineRunner initDatabase(RoleRepository roleRepository,
            UsuarioRepository usuarioRepository,
            PasswordEncoder passwordEncoder) {
        return args -> {
            logger.info("=== INICIANDO CARGA DE DATOS ===");
            
            // Crear roles si no existen
            try {
                createRoleIfNotExists(roleRepository, ERole.ADMIN);
                createRoleIfNotExists(roleRepository, ERole.VENDEDOR);
                createRoleIfNotExists(roleRepository, ERole.ALMACENERO);
                logger.info("‚úì Roles verificados/creados: ADMIN, VENDEDOR, ALMACENERO");
            } catch (Exception e) {
                logger.error("Error al crear roles: {}", e.getMessage());
            }

            // Crear usuario admin si no existe
            try {
                Optional<Usuario> existingAdmin = usuarioRepository.findByUsername("admin");
                
                if (existingAdmin.isEmpty()) {
                    logger.info("Creando usuario administrador...");

                    String rawPassword = "admin123";
                    String encodedPassword = passwordEncoder.encode(rawPassword);

                    Usuario admin = new Usuario();
                    admin.setUsername("admin");
                    admin.setPassword(encodedPassword);
                    admin.setActivo(true);

                    Role adminRole = roleRepository.findByNombre(ERole.ADMIN)
                            .orElseThrow(() -> new RuntimeException("Error: Rol ADMIN no encontrado"));

                    admin.getRoles().add(adminRole);

                    usuarioRepository.save(admin);
                    
                    logger.info("‚úì Usuario admin creado exitosamente");
                    logger.info("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
                    logger.info("‚ïë  CREDENCIALES DE ACCESO               ‚ïë");
                    logger.info("‚ïë  Username: admin                      ‚ïë");
                    logger.info("‚ïë  Password: admin123                   ‚ïë");
                    logger.info("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
                } else {
                    logger.info("‚úì Usuario admin ya existe");
                    logger.info("  Username: admin");
                    logger.info("  Password: admin123");
                }
            } catch (Exception e) {
                logger.error("Error al crear usuario admin: {}", e.getMessage(), e);
            }

            logger.info("=== CARGA DE DATOS COMPLETADA ===\n");
        };
    }
    
    private void createRoleIfNotExists(RoleRepository roleRepository, ERole roleEnum) {
        Optional<Role> existingRole = roleRepository.findByNombre(roleEnum);
        if (existingRole.isEmpty()) {
            Role role = new Role(roleEnum);
            roleRepository.save(role);
            logger.debug("Rol creado: {}", roleEnum);
        } else {
            logger.debug("Rol ya existe: {}", roleEnum);
        }
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/config/DebugFilter.java
------------------------------------------------------------
package com.minimarket.config;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class DebugFilter implements Filter {
    
    private static final Logger logger = LoggerFactory.getLogger(DebugFilter.class);
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String requestURI = httpRequest.getRequestURI();
        String method = httpRequest.getMethod();
        
        logger.debug("üîç Request: {} {} from {}", method, requestURI, httpRequest.getRemoteAddr());
        
        chain.doFilter(request, response);
    }
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/controller/

[FILE] src/main/java/com/minimarket/controller/AuthController.java
------------------------------------------------------------
package com.minimarket.controller;

import com.minimarket.dto.request.LoginRequest;
import com.minimarket.dto.response.JwtResponse;
import com.minimarket.security.jwt.JwtUtils;
import com.minimarket.security.services.UserDetailsImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
public class AuthController {
    
    private static final Logger logger = LoggerFactory.getLogger(AuthController.class);
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @PostMapping("/signin")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        try {
            logger.info("Intento de login para usuario: {}", loginRequest.getUsername());
            
            // Autenticar al usuario con Spring Security
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                    loginRequest.getUsername(), 
                    loginRequest.getPassword()
                )
            );
            
            SecurityContextHolder.getContext().setAuthentication(authentication);
            
            // Generar token JWT
            String jwt = jwtUtils.generateJwtToken(authentication);
            
            // Obtener detalles del usuario autenticado
            UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
            
            // Obtener roles
            List<String> roles = userDetails.getAuthorities().stream()
                .map(item -> item.getAuthority())
                .collect(Collectors.toList());
            
            logger.info("Login exitoso para usuario: {} con roles: {}", userDetails.getUsername(), roles);
            
            // Crear respuesta
            JwtResponse response = new JwtResponse(
                jwt,
                userDetails.getId(),
                userDetails.getUsername(),
                roles
            );
            
            return ResponseEntity.ok(response);
            
        } catch (BadCredentialsException e) {
            logger.error("Credenciales inv√°lidas para usuario: {}", loginRequest.getUsername());
            Map<String, String> error = new HashMap<>();
            error.put("message", "Usuario o contrase√±a incorrectos");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
        } catch (Exception e) {
            logger.error("Error en autenticaci√≥n: ", e);
            Map<String, String> error = new HashMap<>();
            error.put("message", "Error en el proceso de autenticaci√≥n");
            error.put("error", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
        }
    }
    
    @GetMapping("/test")
    public ResponseEntity<String> testAuth() {
        return ResponseEntity.ok("Auth test endpoint works!");
    }
    
    @GetMapping("/validate")
    public ResponseEntity<Map<String, String>> validateToken() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Map<String, String> response = new HashMap<>();
        
        if (authentication != null && authentication.isAuthenticated()) {
            response.put("valid", "true");
            response.put("username", authentication.getName());
            return ResponseEntity.ok(response);
        }
        
        response.put("valid", "false");
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/controller/TestController.java
------------------------------------------------------------
package com.minimarket.controller;

import com.minimarket.repository.RoleRepository;
import com.minimarket.repository.UsuarioRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api")
public class TestController {
    
    @Autowired
    private UsuarioRepository usuarioRepository;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @GetMapping("/public/status")
    public ResponseEntity<Map<String, Object>> getStatus() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "UP");
        response.put("message", "Minimarket Backend funcionando correctamente");
        response.put("timestamp", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        response.put("version", "1.0.0");
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/public/health")
    public ResponseEntity<Map<String, Object>> healthCheck() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "UP");
        response.put("service", "minimarket-backend");
        response.put("timestamp", System.currentTimeMillis());
        response.put("version", "1.0.0");
        response.put("environment", "development");
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/test")
    public ResponseEntity<String> test() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth != null ? auth.getName() : "anonymous";
        return ResponseEntity.ok("Test endpoint works! User: " + username);
    }
    
    @GetMapping("/")
    public ResponseEntity<Map<String, String>> home() {
        Map<String, String> response = new HashMap<>();
        response.put("message", "Minimarket API Backend");
        response.put("status", "Running OK");
        response.put("version", "1.0.0");
        return ResponseEntity.ok(response);
    }
    
    @PostMapping("/public/test-post")
    public ResponseEntity<Map<String, String>> testPost(@RequestBody Map<String, String> request) {
        Map<String, String> response = new HashMap<>();
        response.put("message", "POST recibido correctamente");
        response.put("receivedData", request.getOrDefault("data", "No data provided"));
        response.put("timestamp", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/public/db-check")
    public ResponseEntity<Map<String, Object>> dbCheck() {
        Map<String, Object> response = new HashMap<>();
        try {
            long userCount = usuarioRepository.count();
            long roleCount = roleRepository.count();
            response.put("database", "CONNECTED");
            response.put("status", "OK");
            response.put("userCount", userCount);
            response.put("roleCount", roleCount);
            response.put("timestamp", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("database", "ERROR");
            response.put("status", "FAILED");
            response.put("error", e.getMessage());
            response.put("timestamp", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
            return ResponseEntity.status(500).body(response);
        }
    }
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/dto/

[DIR] src/main/java/com/minimarket/dto/request/

[FILE] src/main/java/com/minimarket/dto/request/LoginRequest.java
------------------------------------------------------------
package com.minimarket.dto.request;

import jakarta.validation.constraints.NotBlank;

public class LoginRequest {
    @NotBlank
    private String username;

    @NotBlank
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

------------------------------------------------------------

[DIR] src/main/java/com/minimarket/dto/response/

[FILE] src/main/java/com/minimarket/dto/response/JwtResponse.java
------------------------------------------------------------
package com.minimarket.dto.response;

import java.util.List;

public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private Long id;
    private String username;
    private List<String> roles;

    public JwtResponse(String accessToken, Long id, String username, List<String> roles) {
        this.token = accessToken;
        this.id = id;
        this.username = username;
        this.roles = roles;
    }

    public String getToken() {
        return token;
    }

    public void setToken(String accessToken) {
        this.token = accessToken;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public List<String> getRoles() {
        return roles;
    }
}

------------------------------------------------------------

[DIR] src/main/java/com/minimarket/entity/

[FILE] src/main/java/com/minimarket/entity/ERole.java
------------------------------------------------------------
package com.minimarket.entity;

public enum ERole {
    ADMIN,
    VENDEDOR,
    ALMACENERO
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/entity/Role.java
------------------------------------------------------------
package com.minimarket.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "roles")
public class Role {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Enumerated(EnumType.STRING)
    @Column(length = 20, unique = true, nullable = false)
    private ERole nombre;
    
    // Constructores
    public Role() {}
    
    public Role(ERole nombre) {
        this.nombre = nombre;
    }
    
    // Getters y Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public ERole getNombre() {
        return nombre;
    }
    
    public void setNombre(ERole nombre) {
        this.nombre = nombre;
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/entity/Usuario.java
------------------------------------------------------------
package com.minimarket.entity;

import jakarta.persistence.*;
// import jakarta.validation.constraints.Email;
// import jakarta.validation.constraints.NotBlank;
// import jakarta.validation.constraints.Size;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "usuarios", 
       uniqueConstraints = {
           @UniqueConstraint(columnNames = "username")
       })
public class Usuario {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // @NotBlank
    // @Size(max = 20)
    @Column(unique = true, nullable = false)
    private String username;
    
    // @NotBlank
    // @Size(max = 120)
    @Column(nullable = false)
    private String password;
    
    @Column(nullable = false)
    private boolean activo = true;
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "usuario_roles",
               joinColumns = @JoinColumn(name = "usuario_id"),
               inverseJoinColumns = @JoinColumn(name = "rol_id"))
    private Set<Role> roles = new HashSet<>();
    
    // Constructores
    public Usuario() {}
    
    public Usuario(String username, String password) {
        this.username = username;
        this.password = password;
    }
    
    // Getters y Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
    
    public boolean isActivo() {
        return activo;
    }
    
    public void setActivo(boolean activo) {
        this.activo = activo;
    }
    
    public Set<Role> getRoles() {
        return roles;
    }
    
    public void setRoles(Set<Role> roles) {
        this.roles = roles;
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/MinimarketApplication.java
------------------------------------------------------------
package com.minimarket;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MinimarketApplication {
    public static void main(String[] args) {
        SpringApplication.run(MinimarketApplication.class, args);
        System.out.println("\n=========================================");
        System.out.println("üöÄ MINIMARKET BACKEND INICIADO CORRECTAMENTE");
        System.out.println("=========================================");
        System.out.println("üåê URL: http://localhost:8080/api");
        System.out.println("üìä Estado: http://localhost:8080/api/public/status");
        System.out.println("üîë Login: POST http://localhost:8080/api/auth/signin");
        System.out.println("   Usuario: admin");
        System.out.println("   Contrase√±a: admin123");
        System.out.println("=========================================\n");
    }
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/repository/

[FILE] src/main/java/com/minimarket/repository/RoleRepository.java
------------------------------------------------------------
package com.minimarket.repository;

import com.minimarket.entity.ERole;
import com.minimarket.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByNombre(ERole nombre);
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/repository/UsuarioRepository.java
------------------------------------------------------------
package com.minimarket.repository;

import com.minimarket.entity.Usuario;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UsuarioRepository extends JpaRepository<Usuario, Long> {
    Optional<Usuario> findByUsername(String username);
    Boolean existsByUsername(String username);
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/security/

[DIR] src/main/java/com/minimarket/security/jwt/

[FILE] src/main/java/com/minimarket/security/jwt/AuthEntryPointJwt.java
------------------------------------------------------------
package com.minimarket.security.jwt;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {

    private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException
    ) throws IOException {

        logger.error("Unauthorized error: {}", authException.getMessage());

        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Map<String, Object> body = new HashMap<>();
        body.put("status", 401);
        body.put("error", "Unauthorized");
        body.put("message", "Token inv√°lido o no enviado");
        body.put("path", request.getServletPath());

        new ObjectMapper().writeValue(response.getOutputStream(), body);
    }
}

------------------------------------------------------------

[FILE] src/main/java/com/minimarket/security/jwt/JwtAuthFilter.java
------------------------------------------------------------
package com.minimarket.security.jwt;

import com.minimarket.security.services.UserDetailsServiceImpl;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.lang.NonNull;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    private static final Logger logger = LoggerFactory.getLogger(JwtAuthFilter.class);

    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = parseJwt(request);

            if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
                String username = jwtUtils.getUserNameFromJwtToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities());

                authentication.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("No se puede autenticar al usuario: {}", e.getMessage());
        }

        filterChain.doFilter(request, response);
    }

    private String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");

        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }

        return null;
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/security/jwt/JwtUtils.java
------------------------------------------------------------
package com.minimarket.security.jwt;

import com.minimarket.security.services.UserDetailsImpl;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

@Component
public class JwtUtils {
    private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expiration}")
    private int jwtExpirationMs;

    public String generateJwtToken(Authentication authentication) {
        UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();

        return Jwts.builder()
                .setSubject(userPrincipal.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    private SecretKey getSigningKey() {
        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String getUserNameFromJwtToken(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }

    public boolean validateJwtToken(String authToken) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(authToken);
            return true;
        } catch (MalformedJwtException e) {
            logger.error("Token JWT inv√°lido: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("Token JWT expirado: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("Token JWT no soportado: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("Cadena de claims JWT est√° vac√≠a: {}", e.getMessage());
        } catch (Exception e) {
            logger.error("Error de validaci√≥n JWT: {}", e.getMessage());
        }

        return false;
    }
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/security/services/

[FILE] src/main/java/com/minimarket/security/services/UserDetailsImpl.java
------------------------------------------------------------
package com.minimarket.security.services;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.minimarket.entity.Usuario;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class UserDetailsImpl implements UserDetails {
    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    @JsonIgnore
    private String password;

    private Collection<? extends GrantedAuthority> authorities;

    public UserDetailsImpl(Long id, String username, String password,
            Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.authorities = authorities;
    }

    public static UserDetailsImpl build(Usuario user) {
        List<GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority(role.getNombre().name()))
                .collect(Collectors.toList());

        return new UserDetailsImpl(
                user.getId(),
                user.getUsername(),
                user.getPassword(),
                authorities);
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    public Long getId() {
        return id;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        UserDetailsImpl user = (UserDetailsImpl) o;
        return Objects.equals(id, user.id);
    }
}

------------------------------------------------------------

[FILE] src/main/java/com/minimarket/security/services/UserDetailsServiceImpl.java
------------------------------------------------------------
package com.minimarket.security.services;

import com.minimarket.entity.Usuario;
import com.minimarket.repository.UsuarioRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    UsuarioRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Usuario user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));

        return UserDetailsImpl.build(user);
    }
}

------------------------------------------------------------

[FILE] src/main/java/com/minimarket/security/WebSecurityConfig.java
------------------------------------------------------------
package com.minimarket.security;

import com.minimarket.security.jwt.AuthEntryPointJwt;
import com.minimarket.security.jwt.JwtAuthFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class WebSecurityConfig {

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private AuthEntryPointJwt unauthorizedHandler;

    @Autowired
    private JwtAuthFilter jwtAuthFilter;

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList(
                "http://localhost:5500",
                "http://127.0.0.1:5500",
                "http://localhost:8080",
                "http://localhost:3000"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setExposedHeaders(Arrays.asList("Authorization"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                // Habilitar CORS
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))

                // Deshabilitar CSRF para APIs REST
                .csrf(csrf -> csrf.disable())

                // Manejar excepciones de autenticaci√≥n
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint(unauthorizedHandler))

                // Configurar pol√≠tica de sesiones (sin estado para APIs REST)
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // Configurar autorizaciones
                .authorizeHttpRequests(auth -> auth
                        // Endpoints p√∫blicos
                        .requestMatchers("/api/auth/**").permitAll()
                        .requestMatchers("/api/public/**").permitAll()
                        .requestMatchers("/error").permitAll()
                        .requestMatchers("/").permitAll()

                        // Endpoints que requieren autenticaci√≥n
                        .anyRequest().authenticated());

        // Configurar el proveedor de autenticaci√≥n
        http.authenticationProvider(authenticationProvider());

        // Agregar el filtro JWT antes del filtro de autenticaci√≥n de usuario/contrase√±a
        http.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
------------------------------------------------------------

[DIR] src/main/resources/

[FILE] src/main/resources/application.yml
------------------------------------------------------------
spring:
  application:
    name: minimarket-backend

  datasource:
    url: jdbc:postgresql://localhost:5432/minimarket_db
    username: postgres
    password: john.007
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
    open-in-view: false

server:
  port: 8080
  servlet:
    context-path: /api
  error:
    include-message: always
    include-binding-errors: always
    include-stacktrace: on_param

# JWT CONFIGURATION
jwt:
  secret: minimarketSecretKey1234567890minimarketSecretKey1234567890
  expiration: 86400000  # 24 horas en milisegundos

# LOGGING CONFIGURATION
logging:
  level:
    root: INFO
    com.minimarket: DEBUG
    org.springframework.security: INFO
    org.springframework.web: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/minimarket-backend.log
    max-size: 10MB
    max-history: 30
------------------------------------------------------------

[DIR] src/test/

[DIR] src/test/java/

[DIR] tools/

[FILE] TreePrinter.class
------------------------------------------------------------
[ERROR: No se pudo leer el archivo - Input length = 1]
------------------------------------------------------------

[FILE] TreePrinter.java
------------------------------------------------------------
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class TreePrinter {

    // Carpetas a ignorar
    private static final Set<String> IGNORED_DIRS = new HashSet<>(Arrays.asList(
            ".git",
            ".vscode",
            ".idea",
            "target",
            "node_modules",
            "dist",
            "build"
    ));

    // Extensiones de archivos a ignorar
    private static final Set<String> IGNORED_EXTENSIONS = new HashSet<>(Arrays.asList(
            ".class",
            ".log",
            ".iml",
            ".lock",
            ".tmp"
    ));

    // Archivos espec√≠ficos a ignorar
    private static final Set<String> IGNORED_FILES = new HashSet<>(Arrays.asList(
            ".DS_Store"
    ));

    public static void main(String[] args) {
        File root = args.length > 0 ? new File(args[0]) : new File(".");

        if (!root.exists()) {
            System.err.println("La ruta no existe");
            return;
        }

        File output = new File("arbol.txt");

        try (PrintWriter writer = new PrintWriter(new FileWriter(output))) {
            writer.println(root.getCanonicalFile().getName());
            printTree(root, "", writer);
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());
            return;
        }

        System.out.println("Archivo arbol.txt creado en: " + output.getAbsolutePath());
    }

    private static void printTree(File dir, String prefix, PrintWriter writer) {
        File[] files = dir.listFiles();
        if (files == null) return;

        Arrays.sort(files, (a, b) -> {
            if (a.isDirectory() && !b.isDirectory()) return -1;
            if (!a.isDirectory() && b.isDirectory()) return 1;
            return a.getName().compareToIgnoreCase(b.getName());
        });

        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            boolean isLast = (i == files.length - 1);

            if (shouldIgnore(file)) continue;

            writer.println(prefix +
                    (isLast ? "\\-- " : "|-- ") +
                    file.getName());

            if (file.isDirectory()) {
                printTree(
                        file,
                        prefix + (isLast ? "    " : "|   "),
                        writer
                );
            }
        }
    }

    private static boolean shouldIgnore(File file) {
        String name = file.getName();

        if (file.isDirectory()) {
            return IGNORED_DIRS.contains(name);
        }

        if (IGNORED_FILES.contains(name)) {
            return true;
        }

        for (String ext : IGNORED_EXTENSIONS) {
            if (name.endsWith(ext)) {
                return true;
            }
        }

        return false;
    }
}

------------------------------------------------------------

================================================================================
ESTADISTICAS:
  Carpetas analizadas: 19
  Archivos incluidos: 25
  Tamanio total: 61820 caracteres
================================================================================
