================================================================================
PROYECTO: minimarket_backend
RUTA: C:\Users\Nvidia\Desktop\minimarket_backend
FECHA: Wed Jan 14 18:17:16 PET 2026
================================================================================


[DIR] logs/

[FILE] pom.xml
------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.4</version> <!-- Versi√≥n m√°s reciente y estable -->
        <relativePath/>
    </parent>
    
    <groupId>com.minimarket</groupId>
    <artifactId>minimarket-backend</artifactId>
    <version>1.0.0</version>
    <name>minimarket-backend</name>
    <description>Sistema de gesti√≥n para minimarket</description>
    
    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.11.5</jjwt.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- JWT Dependencies -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Base de datos -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Lombok para reducir c√≥digo boilerplate -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Desarrollo -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
------------------------------------------------------------

[FILE] ProjectAnalyzer.java
------------------------------------------------------------
import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;

public class ProjectAnalyzer {
    
    // Extensiones de archivos a incluir
    private static final Set<String> INCLUDED_EXTENSIONS = Set.of(
        ".java", ".yml", ".yaml", ".properties", ".xml", 
        ".sql", ".txt", ".md", ".json", ".html", ".css", ".js"
    );
    
    // Carpetas y archivos a ignorar
    private static final Set<String> IGNORED_DIRS = Set.of(
        ".git", ".vscode", ".idea", "node_modules", "target",
        "build", "dist", "out", "__pycache__", ".metadata"
    );
    
    private static final Set<String> IGNORED_FILES = Set.of(
        ".gitignore", ".env", ".env.local", ".env.production",
        ".classpath", ".project", ".settings", "Thumbs.db",
        "Desktop.ini", ".DS_Store", "compilado.txt"
    );
    
    // Archivos espec√≠ficos a incluir
    private static final Set<String> SPECIFIC_FILES = Set.of(
        "pom.xml", "build.gradle", "package.json", "README.md",
        "Dockerfile", "docker-compose.yml", "Makefile"
    );
    
    public static void main(String[] args) {
        String currentDir = System.getProperty("user.dir");
        System.out.println("ANALIZANDO DIRECTORIO: " + currentDir);
        
        try {
            String output = analyzeProject(Paths.get(currentDir));
            
            // Guardar en archivo
            Path outputFile = Paths.get(currentDir, "compilado.txt");
            Files.writeString(outputFile, output, 
                StandardOpenOption.CREATE, 
                StandardOpenOption.TRUNCATE_EXISTING);
            
            System.out.println("ARCHIVO CREADO: " + outputFile.toAbsolutePath());
            System.out.println("TOTAL LINEAS: " + output.lines().count());
            
        } catch (IOException e) {
            System.err.println("ERROR: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private static String analyzeProject(Path rootDir) throws IOException {
        StringBuilder result = new StringBuilder();
        
        // Cabecera
        result.append("=".repeat(80)).append("\n");
        result.append("PROYECTO: ").append(rootDir.getFileName()).append("\n");
        result.append("RUTA: ").append(rootDir.toAbsolutePath()).append("\n");
        result.append("FECHA: ").append(new Date()).append("\n");
        result.append("=".repeat(80)).append("\n\n");
        
        // Recorrer el √°rbol de directorios
        Files.walkFileTree(rootDir, new SimpleFileVisitor<Path>() {
            private int fileCount = 0;
            private int dirCount = 0;
            
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                String dirName = dir.getFileName().toString();
                
                // Ignorar carpetas no deseadas
                if (IGNORED_DIRS.contains(dirName) || dirName.startsWith(".")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                
                // No incluir la carpeta ra√≠z en el conteo
                if (!dir.equals(rootDir)) {
                    dirCount++;
                    result.append("\n[DIR] ").append(getRelativePath(rootDir, dir)).append("/\n");
                }
                
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                String fileName = file.getFileName().toString();
                
                // Ignorar archivos no deseados
                if (IGNORED_FILES.contains(fileName) || fileName.startsWith(".")) {
                    return FileVisitResult.CONTINUE;
                }
                
                // Verificar si el archivo debe ser incluido
                if (shouldIncludeFile(file)) {
                    fileCount++;
                    result.append("\n[FILE] ").append(getRelativePath(rootDir, file)).append("\n");
                    result.append("-".repeat(60)).append("\n");
                    
                    try {
                        String content = Files.readString(file);
                        result.append(content).append("\n");
                    } catch (IOException e) {
                        result.append("[ERROR: No se pudo leer el archivo - ").append(e.getMessage()).append("]\n");
                    }
                    
                    result.append("-".repeat(60)).append("\n");
                }
                
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                // Estad√≠sticas al final
                if (dir.equals(rootDir)) {
                    result.append("\n").append("=".repeat(80)).append("\n");
                    result.append("ESTADISTICAS:\n");
                    result.append("  Carpetas analizadas: ").append(dirCount).append("\n");
                    result.append("  Archivos incluidos: ").append(fileCount).append("\n");
                    result.append("  Tamanio total: ").append(result.length()).append(" caracteres\n");
                    result.append("=".repeat(80)).append("\n");
                }
                return FileVisitResult.CONTINUE;
            }
        });
        
        return result.toString();
    }
    
    private static boolean shouldIncludeFile(Path file) {
        String fileName = file.getFileName().toString();
        
        // Incluir archivos espec√≠ficos
        if (SPECIFIC_FILES.contains(fileName)) {
            return true;
        }
        
        // Verificar extensi√≥n
        int dotIndex = fileName.lastIndexOf('.');
        if (dotIndex > 0) {
            String extension = fileName.substring(dotIndex).toLowerCase();
            return INCLUDED_EXTENSIONS.contains(extension);
        }
        
        return false;
    }
    
    private static String getRelativePath(Path root, Path target) {
        return root.relativize(target).toString().replace("\\", "/");
    }
}
------------------------------------------------------------

[FILE] readme.md
------------------------------------------------------------
mvn spring-boot:run

http://localhost:8080/api/public/status

http://localhost:8080/api/public/health
------------------------------------------------------------

[DIR] src/

[DIR] src/main/

[DIR] src/main/java/

[DIR] src/main/java/com/

[DIR] src/main/java/com/minimarket/

[DIR] src/main/java/com/minimarket/config/

[FILE] src/main/java/com/minimarket/config/CorsConfig.java
------------------------------------------------------------
package com.minimarket.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig {
    
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                // Configuraci√≥n CORS para el frontend
                registry.addMapping("/api/**")
                        .allowedOrigins("http://localhost:5500", "http://127.0.0.1:5500", 
                                       "http://localhost:8080", "http://localhost:3000")
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH")
                        .allowedHeaders("*")
                        .exposedHeaders("Authorization")
                        .allowCredentials(true)
                        .maxAge(3600);
                
                // Tambi√©n para rutas sin /api por si acaso
                registry.addMapping("/**")
                        .allowedOrigins("http://localhost:5500", "http://127.0.0.1:5500")
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .allowedHeaders("*")
                        .allowCredentials(true)
                        .maxAge(3600);
            }
        };
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/config/DataLoader.java
------------------------------------------------------------
package com.minimarket.config;

import com.minimarket.entity.ERole;
import com.minimarket.entity.Role;
import com.minimarket.entity.Usuario;
import com.minimarket.repository.RoleRepository;
import com.minimarket.repository.UsuarioRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Configuration
public class DataLoader {

    private static final Logger logger = LoggerFactory.getLogger(DataLoader.class);

    @Bean
    CommandLineRunner initDatabase(RoleRepository roleRepository,
            UsuarioRepository usuarioRepository,
            PasswordEncoder passwordEncoder) {
        return args -> {
            logger.info("=== INICIANDO CARGA DE DATOS ===");
            
            // Crear roles si no existen
            if (roleRepository.count() == 0) {
                logger.info("Creando roles iniciales...");

                Role adminRole = new Role(ERole.ADMIN);
                Role vendedorRole = new Role(ERole.VENDEDOR);
                Role almaceneroRole = new Role(ERole.ALMACENERO);

                roleRepository.save(adminRole);
                roleRepository.save(vendedorRole);
                roleRepository.save(almaceneroRole);

                logger.info("‚úì Roles creados: ADMIN, VENDEDOR, ALMACENERO");
            } else {
                logger.info("‚úì Roles ya existen en la base de datos");
            }

            // Crear usuario admin si no existe
            if (usuarioRepository.findByUsername("admin").isEmpty()) {
                logger.info("Creando usuario administrador...");

                String rawPassword = "admin123";
                String encodedPassword = passwordEncoder.encode(rawPassword);
                
                logger.debug("Password original: {}", rawPassword);
                logger.debug("Password encriptado: {}", encodedPassword);

                Usuario admin = new Usuario();
                admin.setUsername("admin");
                admin.setPassword(encodedPassword);
                admin.setActivo(true);

                Role adminRole = roleRepository.findByNombre(ERole.ADMIN)
                        .orElseThrow(() -> new RuntimeException("Error: Rol ADMIN no encontrado"));

                admin.getRoles().add(adminRole);

                usuarioRepository.save(admin);
                logger.info("‚úì Usuario admin creado");
                logger.info("  Username: admin");
                logger.info("  Password: admin123");
            } else {
                logger.info("‚úì Usuario admin ya existe");
            }

            logger.info("=== CARGA DE DATOS COMPLETADA ===");
        };
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/config/DebugFilter.java
------------------------------------------------------------
package com.minimarket.config;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class DebugFilter implements Filter {
    
    private static final Logger logger = LoggerFactory.getLogger(DebugFilter.class);
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String requestURI = httpRequest.getRequestURI();
        String method = httpRequest.getMethod();
        
        logger.debug("üîç Request: {} {} from {}", method, requestURI, httpRequest.getRemoteAddr());
        
        chain.doFilter(request, response);
    }
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/controller/

[FILE] src/main/java/com/minimarket/controller/AuthController.java
------------------------------------------------------------
package com.minimarket.controller;

import com.minimarket.dto.request.LoginRequest;
import com.minimarket.dto.response.JwtResponse;
import com.minimarket.security.jwt.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @PostMapping("/signin")
    public ResponseEntity<?> authenticateUser(@RequestBody LoginRequest loginRequest) {
        try {
            // Autenticar al usuario con Spring Security
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                    loginRequest.getUsername(), 
                    loginRequest.getPassword()
                )
            );
            
            SecurityContextHolder.getContext().setAuthentication(authentication);
            
            // Generar token JWT
            String jwt = jwtUtils.generateJwtToken(authentication);
            
            // Obtener detalles del usuario autenticado
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            
            // Obtener roles
            List<String> roles = userDetails.getAuthorities().stream()
                .map(item -> item.getAuthority())
                .collect(Collectors.toList());
            
            // Crear respuesta
            JwtResponse response = new JwtResponse(
                jwt,
                1L, // ID temporal - deber√≠as obtenerlo de la base de datos
                userDetails.getUsername(),
                roles
            );
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            return ResponseEntity
                .badRequest()
                .body("Error de autenticaci√≥n: " + e.getMessage());
        }
    }
    
    @GetMapping("/test")
    public String testAuth() {
        return "Auth test endpoint works!";
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/controller/TestController.java
------------------------------------------------------------
package com.minimarket.controller;

import com.minimarket.repository.RoleRepository;
import com.minimarket.repository.UsuarioRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api")
public class TestController {
    
    @Autowired
    private UsuarioRepository usuarioRepository;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @GetMapping("/public/status")
    public String getStatus() {
        return "‚úÖ Minimarket Backend funcionando - " + System.currentTimeMillis();
    }
    
    @GetMapping("/public/health")
    public Map<String, Object> healthCheck() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "UP");
        response.put("service", "minimarket-backend");
        response.put("timestamp", System.currentTimeMillis());
        response.put("version", "1.0.0");
        return response;
    }
    
    @GetMapping("/test")
    public String test() {
        return "Test endpoint works!";
    }
    
    @GetMapping("/")
    public String home() {
        return "Minimarket API Backend - Running OK";
    }
    
    @PostMapping("/public/test-post")
    public Map<String, String> testPost(@RequestBody Map<String, String> request) {
        Map<String, String> response = new HashMap<>();
        response.put("message", "POST recibido correctamente");
        response.put("data", request.get("data"));
        response.put("timestamp", String.valueOf(System.currentTimeMillis()));
        return response;
    }
    
    @GetMapping("/public/db-check")
    public Map<String, Object> dbCheck() {
        Map<String, Object> response = new HashMap<>();
        try {
            long userCount = usuarioRepository.count();
            long roleCount = roleRepository.count();
            response.put("database", "OK");
            response.put("userCount", userCount);
            response.put("roleCount", roleCount);
            response.put("timestamp", System.currentTimeMillis());
            return response;
        } catch (Exception e) {
            response.put("database", "ERROR");
            response.put("error", e.getMessage());
            response.put("timestamp", System.currentTimeMillis());
            return response;
        }
    }
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/dto/

[DIR] src/main/java/com/minimarket/dto/request/

[FILE] src/main/java/com/minimarket/dto/request/LoginRequest.java
------------------------------------------------------------
package com.minimarket.dto.request;

import jakarta.validation.constraints.NotBlank;

public class LoginRequest {
    @NotBlank
    private String username;

    @NotBlank
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

------------------------------------------------------------

[DIR] src/main/java/com/minimarket/dto/response/

[FILE] src/main/java/com/minimarket/dto/response/JwtResponse.java
------------------------------------------------------------
package com.minimarket.dto.response;

import java.util.List;

public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private Long id;
    private String username;
    private List<String> roles;

    public JwtResponse(String accessToken, Long id, String username, List<String> roles) {
        this.token = accessToken;
        this.id = id;
        this.username = username;
        this.roles = roles;
    }

    public String getToken() {
        return token;
    }

    public void setToken(String accessToken) {
        this.token = accessToken;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public List<String> getRoles() {
        return roles;
    }
}

------------------------------------------------------------

[DIR] src/main/java/com/minimarket/entity/

[FILE] src/main/java/com/minimarket/entity/ERole.java
------------------------------------------------------------
package com.minimarket.entity;

public enum ERole {
    ADMIN,
    VENDEDOR,
    ALMACENERO
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/entity/Role.java
------------------------------------------------------------
package com.minimarket.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "roles")
public class Role {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Enumerated(EnumType.STRING)
    @Column(length = 20, unique = true, nullable = false)
    private ERole nombre;
    
    // Constructores
    public Role() {}
    
    public Role(ERole nombre) {
        this.nombre = nombre;
    }
    
    // Getters y Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public ERole getNombre() {
        return nombre;
    }
    
    public void setNombre(ERole nombre) {
        this.nombre = nombre;
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/entity/Usuario.java
------------------------------------------------------------
package com.minimarket.entity;

import jakarta.persistence.*;
// import jakarta.validation.constraints.Email;
// import jakarta.validation.constraints.NotBlank;
// import jakarta.validation.constraints.Size;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "usuarios", 
       uniqueConstraints = {
           @UniqueConstraint(columnNames = "username")
       })
public class Usuario {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // @NotBlank
    // @Size(max = 20)
    @Column(unique = true, nullable = false)
    private String username;
    
    // @NotBlank
    // @Size(max = 120)
    @Column(nullable = false)
    private String password;
    
    @Column(nullable = false)
    private boolean activo = true;
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "usuario_roles",
               joinColumns = @JoinColumn(name = "usuario_id"),
               inverseJoinColumns = @JoinColumn(name = "rol_id"))
    private Set<Role> roles = new HashSet<>();
    
    // Constructores
    public Usuario() {}
    
    public Usuario(String username, String password) {
        this.username = username;
        this.password = password;
    }
    
    // Getters y Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
    
    public boolean isActivo() {
        return activo;
    }
    
    public void setActivo(boolean activo) {
        this.activo = activo;
    }
    
    public Set<Role> getRoles() {
        return roles;
    }
    
    public void setRoles(Set<Role> roles) {
        this.roles = roles;
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/MinimarketApplication.java
------------------------------------------------------------
package com.minimarket;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MinimarketApplication {
    public static void main(String[] args) {
        SpringApplication.run(MinimarketApplication.class, args);
        System.out.println("\n=========================================");
        System.out.println("üöÄ MINIMARKET BACKEND INICIADO CORRECTAMENTE");
        System.out.println("=========================================");
        System.out.println("üåê URL: http://localhost:8080/api");
        System.out.println("üìä Estado: http://localhost:8080/api/public/status");
        System.out.println("üîë Login: POST http://localhost:8080/api/auth/signin");
        System.out.println("   Usuario: admin");
        System.out.println("   Contrase√±a: admin123");
        System.out.println("=========================================\n");
    }
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/repository/

[FILE] src/main/java/com/minimarket/repository/RoleRepository.java
------------------------------------------------------------
package com.minimarket.repository;

import com.minimarket.entity.ERole;
import com.minimarket.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByNombre(ERole nombre);
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/repository/UsuarioRepository.java
------------------------------------------------------------
package com.minimarket.repository;

import com.minimarket.entity.Usuario;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UsuarioRepository extends JpaRepository<Usuario, Long> {
    Optional<Usuario> findByUsername(String username);
    Boolean existsByUsername(String username);
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/security/

[DIR] src/main/java/com/minimarket/security/jwt/

[FILE] src/main/java/com/minimarket/security/jwt/AuthEntryPointJwt.java
------------------------------------------------------------
package com.minimarket.security.jwt;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {

    private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
            AuthenticationException authException) throws IOException, ServletException {
        logger.error("Unauthorized error: {}", authException.getMessage());
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Error: Unauthorized");
    }
}

------------------------------------------------------------

[FILE] src/main/java/com/minimarket/security/jwt/JwtAuthFilter.java
------------------------------------------------------------
package com.minimarket.security.jwt;

import com.minimarket.security.services.UserDetailsServiceImpl;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @Autowired
    private UserDetailsServiceImpl userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = parseJwt(request);
            
            if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
                String username = jwtUtils.getUserNameFromJwtToken(jwt);
                
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(
                        userDetails, 
                        null, 
                        userDetails.getAuthorities()
                    );
                
                authentication.setDetails(
                    new WebAuthenticationDetailsSource().buildDetails(request)
                );
                
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("No se puede autenticar al usuario: {}", e.getMessage());
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");
        
        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }
        
        return null;
    }
}
------------------------------------------------------------

[FILE] src/main/java/com/minimarket/security/jwt/JwtUtils.java
------------------------------------------------------------
package com.minimarket.security.jwt;

import com.minimarket.security.services.UserDetailsImpl;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtUtils {
    private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

    private final String jwtSecret = "minimarketSecretKey1234567890minimarketSecretKey1234567890";
    private final int jwtExpirationMs = 86400000; // 24 horas

    public String generateJwtToken(Authentication authentication) {
        UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();

        return Jwts.builder()
                .setSubject(userPrincipal.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                .signWith(key(), SignatureAlgorithm.HS256)
                .compact();
    }

    private Key key() {
        return Keys.hmacShaKeyFor(jwtSecret.getBytes());
    }

    public String getUserNameFromJwtToken(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(key())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }

    public boolean validateJwtToken(String authToken) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(key())
                    .build()
                    .parseClaimsJws(authToken);
            return true;
        } catch (MalformedJwtException e) {
            logger.error("Token JWT inv√°lido: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("Token JWT expirado: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("Token JWT no soportado: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("Cadena de claims JWT est√° vac√≠a: {}", e.getMessage());
        } catch (Exception e) {
            logger.error("Error de validaci√≥n JWT: {}", e.getMessage());
        }

        return false;
    }
}
------------------------------------------------------------

[DIR] src/main/java/com/minimarket/security/services/

[FILE] src/main/java/com/minimarket/security/services/UserDetailsImpl.java
------------------------------------------------------------
package com.minimarket.security.services;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.minimarket.entity.Usuario;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class UserDetailsImpl implements UserDetails {
    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    @JsonIgnore
    private String password;

    private Collection<? extends GrantedAuthority> authorities;

    public UserDetailsImpl(Long id, String username, String password,
            Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.authorities = authorities;
    }

    public static UserDetailsImpl build(Usuario user) {
        List<GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority(role.getNombre().name()))
                .collect(Collectors.toList());

        return new UserDetailsImpl(
                user.getId(),
                user.getUsername(),
                user.getPassword(),
                authorities);
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    public Long getId() {
        return id;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        UserDetailsImpl user = (UserDetailsImpl) o;
        return Objects.equals(id, user.id);
    }
}

------------------------------------------------------------

[FILE] src/main/java/com/minimarket/security/services/UserDetailsServiceImpl.java
------------------------------------------------------------
package com.minimarket.security.services;

import com.minimarket.entity.Usuario;
import com.minimarket.repository.UsuarioRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    UsuarioRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Usuario user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));

        return UserDetailsImpl.build(user);
    }
}

------------------------------------------------------------

[FILE] src/main/java/com/minimarket/security/WebSecurityConfig.java
------------------------------------------------------------
package com.minimarket.security;

import com.minimarket.security.jwt.AuthEntryPointJwt;
import com.minimarket.security.jwt.JwtAuthFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class WebSecurityConfig {
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Autowired
    private AuthEntryPointJwt unauthorizedHandler;
    
    @Autowired
    private JwtAuthFilter jwtAuthFilter;
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // Deshabilitar CSRF para APIs REST
            .csrf(csrf -> csrf.disable())
            
            // Manejar excepciones de autenticaci√≥n
            .exceptionHandling(exception -> exception
                .authenticationEntryPoint(unauthorizedHandler)
            )
            
            // Configurar pol√≠tica de sesiones (sin estado para APIs REST)
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            
            // Configurar autorizaciones
            .authorizeHttpRequests(auth -> auth
                // Endpoints p√∫blicos
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/error").permitAll()
                
                // Endpoints que requieren autenticaci√≥n
                .anyRequest().authenticated()
            );
        
        // Configurar el proveedor de autenticaci√≥n
        http.authenticationProvider(authenticationProvider());
        
        // Agregar el filtro JWT antes del filtro de autenticaci√≥n de usuario/contrase√±a
        http.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
------------------------------------------------------------

[DIR] src/main/resources/

[FILE] src/main/resources/application.yml
------------------------------------------------------------
spring:
  application:
    name: minimarket-backend

  datasource:
    url: jdbc:postgresql://localhost:5432/minimarket_db
    username: postgres
    password: john.007
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true  # Cambiar a true para debugging
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
    open-in-view: false

server:
  port: 8080
  servlet:
    context-path: /api
  error:
    include-message: always
    include-binding-errors: always

# LOGGING MEJORADO PARA DEBUGGING
logging:
  level:
    root: INFO
    com.minimarket: DEBUG
    org.springframework.security: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

# JWT CONFIGURATION
jwt:
  secret: minimarketSecretKey1234567890minimarketSecretKey1234567890
  expiration: 86400000  # 24 horas en milisegundos
------------------------------------------------------------

[DIR] src/test/

[DIR] src/test/java/

[DIR] tools/

[FILE] TreePrinter.java
------------------------------------------------------------
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class TreePrinter {

    // Carpetas a ignorar
    private static final Set<String> IGNORED_DIRS = new HashSet<>(Arrays.asList(
            ".git",
            ".vscode",
            ".idea",
            "target",
            "node_modules",
            "dist",
            "build"
    ));

    // Extensiones de archivos a ignorar
    private static final Set<String> IGNORED_EXTENSIONS = new HashSet<>(Arrays.asList(
            ".class",
            ".log",
            ".iml",
            ".lock",
            ".tmp"
    ));

    // Archivos espec√≠ficos a ignorar
    private static final Set<String> IGNORED_FILES = new HashSet<>(Arrays.asList(
            ".DS_Store"
    ));

    public static void main(String[] args) {
        File root = args.length > 0 ? new File(args[0]) : new File(".");

        if (!root.exists()) {
            System.err.println("La ruta no existe");
            return;
        }

        File output = new File("arbol.txt");

        try (PrintWriter writer = new PrintWriter(new FileWriter(output))) {
            writer.println(root.getCanonicalFile().getName());
            printTree(root, "", writer);
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());
            return;
        }

        System.out.println("Archivo arbol.txt creado en: " + output.getAbsolutePath());
    }

    private static void printTree(File dir, String prefix, PrintWriter writer) {
        File[] files = dir.listFiles();
        if (files == null) return;

        Arrays.sort(files, (a, b) -> {
            if (a.isDirectory() && !b.isDirectory()) return -1;
            if (!a.isDirectory() && b.isDirectory()) return 1;
            return a.getName().compareToIgnoreCase(b.getName());
        });

        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            boolean isLast = (i == files.length - 1);

            if (shouldIgnore(file)) continue;

            writer.println(prefix +
                    (isLast ? "\\-- " : "|-- ") +
                    file.getName());

            if (file.isDirectory()) {
                printTree(
                        file,
                        prefix + (isLast ? "    " : "|   "),
                        writer
                );
            }
        }
    }

    private static boolean shouldIgnore(File file) {
        String name = file.getName();

        if (file.isDirectory()) {
            return IGNORED_DIRS.contains(name);
        }

        if (IGNORED_FILES.contains(name)) {
            return true;
        }

        for (String ext : IGNORED_EXTENSIONS) {
            if (name.endsWith(ext)) {
                return true;
            }
        }

        return false;
    }
}

------------------------------------------------------------

================================================================================
ESTADISTICAS:
  Carpetas analizadas: 20
  Archivos incluidos: 24
  Tamanio total: 50435 caracteres
================================================================================
